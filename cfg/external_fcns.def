 ///////////////////////////////////////////////////////////
//          Matching predicates
///////////////////////////////////////////////////////////
        PRED [LFTA_LEGAL, COST HIGH]str_exists_substr[string, string];
        PRED [LFTA_LEGAL, COST HIGH]str_compare[string,string];
        PRED [LFTA_LEGAL, COST LOW] str_match_offset [uint,string,string];
        PRED [LFTA_LEGAL, COST LOW] byte_match_offset [uint,uint,string];
    
///////////////////////////////////////////////////////////
//          MIN/MAX functions
///////////////////////////////////////////////////////////

// return ullong
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (uint,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (uint,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (uint,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (uint,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (uint,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (int,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (int,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (int,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (int,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (int,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (ullong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (ullong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (ullong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (ullong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (ullong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (llong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (llong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (llong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (llong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (llong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (float,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (float,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (float,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (float,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMIN (float,float);

        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (uint,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (uint,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (uint,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (uint,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (uint,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (int,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (int,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (int,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (int,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (int,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (ullong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (ullong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (ullong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (ullong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (ullong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (llong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (llong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (llong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (llong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (llong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (float,int);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (float,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (float,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (float,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] ULLMAX (float,float);

// return llong
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (uint,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (uint,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (uint,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (uint,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (uint,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (int,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (int,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (int,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (int,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (int,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (ullong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (ullong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (ullong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (ullong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (ullong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (llong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (llong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (llong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (llong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (llong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (float,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (float,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (float,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (float,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMIN (float,float);

        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (uint,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (uint,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (uint,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (uint,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (uint,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (int,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (int,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (int,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (int,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (int,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (ullong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (ullong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (ullong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (ullong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (ullong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (llong,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (llong,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (llong,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (llong,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (llong,float);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (float,int);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (float,uint);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (float,llong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (float,ullong);
        ullong FUN [LFTA_LEGAL, COST FREE] LLMAX (float,float);

// return uint
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (uint,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (uint,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (uint,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (uint,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (uint,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (int,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (int,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (int,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (int,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (int,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (ullong,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (ullong,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (ullong,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (ullong,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (ullong,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (llong,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (llong,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (llong,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (llong,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (llong,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (float,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (float,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (float,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (float,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMIN (float,float);

        uint FUN [LFTA_LEGAL, COST FREE] UMAX (uint,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (uint,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (uint,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (uint,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (uint,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (int,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (int,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (int,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (int,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (int,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (ullong,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (ullong,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (ullong,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (ullong,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (ullong,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (llong,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (llong,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (llong,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (llong,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (llong,float);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (float,int);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (float,uint);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (float,llong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (float,ullong);
        uint FUN [LFTA_LEGAL, COST FREE] UMAX (float,float);

// return int
        int FUN [LFTA_LEGAL, COST FREE] LMIN (uint,int);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (uint,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (uint,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (uint,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (uint,float);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (int,int);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (int,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (int,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (int,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (int,float);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (ullong,int);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (ullong,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (ullong,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (ullong,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (ullong,float);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (llong,int);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (llong,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (llong,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (llong,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (llong,float);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (float,int);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (float,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (float,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (float,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMIN (float,float);

        int FUN [LFTA_LEGAL, COST FREE] LMAX (uint,int);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (uint,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (uint,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (uint,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (uint,float);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (int,int);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (int,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (int,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (int,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (int,float);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (ullong,int);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (ullong,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (ullong,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (ullong,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (ullong,float);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (llong,int);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (llong,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (llong,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (llong,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (llong,float);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (float,int);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (float,uint);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (float,llong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (float,ullong);
        int FUN [LFTA_LEGAL, COST FREE] LMAX (float,float);

// return float
        float FUN [LFTA_LEGAL, COST FREE] FMIN (uint,int);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (uint,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (uint,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (uint,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (uint,float);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (int,int);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (int,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (int,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (int,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (int,float);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (ullong,int);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (ullong,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (ullong,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (ullong,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (ullong,float);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (llong,int);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (llong,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (llong,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (llong,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (llong,float);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (float,int);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (float,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (float,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (float,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMIN (float,float);

        float FUN [LFTA_LEGAL, COST FREE] FMAX (uint,int);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (uint,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (uint,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (uint,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (uint,float);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (int,int);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (int,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (int,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (int,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (int,float);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (ullong,int);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (ullong,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (ullong,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (ullong,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (ullong,float);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (llong,int);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (llong,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (llong,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (llong,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (llong,float);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (float,int);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (float,uint);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (float,llong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (float,ullong);
        float FUN [LFTA_LEGAL, COST FREE] FMAX (float,float);

// return IP
        IP FUN [LFTA_LEGAL, COST FREE] UMIN (IP,IP);
        IP FUN [LFTA_LEGAL, COST FREE] UMAX (IP,IP);
   
///////////////////////////////////////////////////////////
//          conditional functions
///////////////////////////////////////////////////////////

// rhs == lhs
	uint FUN [LFTA_LEGAL, COST FREE] EQ (uint, int);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (uint, uint);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (uint, llong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (uint, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (uint, float);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (int, int);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (int, llong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (int, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (int, float);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (ullong, int);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (ullong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (ullong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (ullong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (ullong, float);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (llong, int);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (llong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (llong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (llong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (llong, float);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (float, int);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (float, uint);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (float, llong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (float, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] EQ (float, float);

// rhs >= lhs
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (uint, int);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (uint, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (uint, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (uint, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (uint, float);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (int, int);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (int, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (int, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (int, float);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (ullong, int);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (ullong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (ullong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (ullong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (ullong, float);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (llong, int);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (llong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (llong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (llong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (llong, float);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (float, int);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (float, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (float, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (float, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GEQ (float, float);

// rhs > lhs
	uint FUN [LFTA_LEGAL, COST FREE] GE (uint, int);
	uint FUN [LFTA_LEGAL, COST FREE] GE (uint, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GE (uint, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (uint, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (uint, float);
	uint FUN [LFTA_LEGAL, COST FREE] GE (int, int);
	uint FUN [LFTA_LEGAL, COST FREE] GE (int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GE (int, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (int, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (int, float);
	uint FUN [LFTA_LEGAL, COST FREE] GE (ullong, int);
	uint FUN [LFTA_LEGAL, COST FREE] GE (ullong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GE (ullong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (ullong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (ullong, float);
	uint FUN [LFTA_LEGAL, COST FREE] GE (llong, int);
	uint FUN [LFTA_LEGAL, COST FREE] GE (llong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GE (llong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (llong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (llong, float);
	uint FUN [LFTA_LEGAL, COST FREE] GE (float, int);
	uint FUN [LFTA_LEGAL, COST FREE] GE (float, uint);
	uint FUN [LFTA_LEGAL, COST FREE] GE (float, llong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (float, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] GE (float, float);

// rhs <= lhs
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (uint, int);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (uint, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (uint, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (uint, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (uint, float);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (int, int);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (int, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (int, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (int, float);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (ullong, int);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (ullong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (ullong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (ullong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (ullong, float);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (llong, int);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (llong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (llong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (llong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (llong, float);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (float, int);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (float, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (float, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (float, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LEQ (float, float);

// rhs < lhs
	uint FUN [LFTA_LEGAL, COST FREE] LE (uint, int);
	uint FUN [LFTA_LEGAL, COST FREE] LE (uint, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LE (uint, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (uint, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (uint, float);
	uint FUN [LFTA_LEGAL, COST FREE] LE (int, int);
	uint FUN [LFTA_LEGAL, COST FREE] LE (int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LE (int, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (int, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (int, float);
	uint FUN [LFTA_LEGAL, COST FREE] LE (ullong, int);
	uint FUN [LFTA_LEGAL, COST FREE] LE (ullong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LE (ullong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (ullong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (ullong, float);
	uint FUN [LFTA_LEGAL, COST FREE] LE (llong, int);
	uint FUN [LFTA_LEGAL, COST FREE] LE (llong, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LE (llong, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (llong, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (llong, float);
	uint FUN [LFTA_LEGAL, COST FREE] LE (float, int);
	uint FUN [LFTA_LEGAL, COST FREE] LE (float, uint);
	uint FUN [LFTA_LEGAL, COST FREE] LE (float, llong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (float, ullong);
	uint FUN [LFTA_LEGAL, COST FREE] LE (float, float);

//////////////////////////////////////////////////////////////
//	Conditional evaluation
//		add int, uint in the else clause to allow for constants
///////////////////////////////////////////////////////

	int FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, int, int);
	int FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, int, uint);
	uint FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, uint, uint); 
	uint FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, uint, int);
	llong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, llong, llong);
	llong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, llong, uint);
	llong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, llong, int);
	ullong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, ullong, ullong);
	ullong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, ullong, int);
	ullong FUN [LFTA_LEGAL, COST FREE] if_else_i(uint, ullong, uint);


///////////////////////////////////////////////////////////
//          Function for regex matching
///////////////////////////////////////////////////////////

	uint FUN [LFTA_LEGAL] endian_swap_ui(uint);

///////////////////////////////////////////////////////////
//          Function for regex matching
///////////////////////////////////////////////////////////


uint FUN [LFTA_LEGAL, COST EXPENSIVE]
		str_regex_match( string, string HANDLE);
	uint FUN [LFTA_LEGAL, COST EXPENSIVE] 
		str_partial_regex_match( string, string HANDLE, uint);
	string FUN [PARTIAL, COST EXPENSIVE] str_extract_regex( string, string HANDLE);
  

///////////////////////////////////////////////////////////
//         Truncating strings and substrings
///////////////////////////////////////////////////////////
       
// str_truncate(str, n) : return the 1st n chars of str, or as much as possible
        string FUN [LFTA_LEGAL,PARTIAL,COST FREE] str_truncate (string, uint);
// str_suffix(str, n) : return the last n chars of str, or as much as possible
        string FUN [LFTA_LEGAL,PARTIAL,COST FREE] str_suffix (string, uint);
// get_list_entry(list_str, sep_str, i) : split the list by sep,
//		return the i-th value, if it exists.
        string FUN [LFTA_LEGAL,PARTIAL,COST FREE] get_list_entry (string, string, uint CONST);


///////////////////////////////////////////////////////////
//         hashing
///////////////////////////////////////////////////////////

	uint FUN [LFTA_LEGAL] string_hash(string);
	ullong FUN string_hash_long(string);

 
///////////////////////////////////////////////////////////
//          Function for casting
///////////////////////////////////////////////////////////

    int FUN [LFTA_LEGAL,COST FREE] non_temporal(int);
	uint FUN [LFTA_LEGAL,COST FREE] non_temporal(uint);
	llong FUN [LFTA_LEGAL,COST FREE] non_temporal(llong);
	ullong FUN [LFTA_LEGAL,COST FREE] non_temporal(ullong);

	int FUN [LFTA_LEGAL,COST FREE]INT(uint);
	int FUN [LFTA_LEGAL,COST FREE]INT(int);
    int FUN [LFTA_LEGAL,COST FREE]INT(ullong);
    int FUN [LFTA_LEGAL,COST FREE]INT(llong);
    int FUN [LFTA_LEGAL,COST FREE]INT(float);
 
    uint FUN [LFTA_LEGAL,COST FREE]UINT(uint);
    uint FUN [LFTA_LEGAL,COST FREE]UINT(int);
    uint FUN [LFTA_LEGAL,COST FREE]UINT(ullong);
    uint FUN [LFTA_LEGAL,COST FREE]UINT(llong);
    uint FUN [LFTA_LEGAL,COST FREE]UINT(float);
	uint FUN [LFTA_LEGAL,COST FREE]UINT(IP);

	float FUN [LFTA_LEGAL,COST FREE] FLOAT(llong);
	float FUN [LFTA_LEGAL,COST FREE] FLOAT(float);
	float FUN [LFTA_LEGAL,COST FREE] FLOAT(ullong);
	float FUN [LFTA_LEGAL,COST FREE] FLOAT(int);
	float FUN [LFTA_LEGAL,COST FREE] FLOAT(uint);

	ullong FUN [LFTA_LEGAL,COST FREE]ULLONG(uint);
	ullong FUN [LFTA_LEGAL,COST FREE]ULLONG(int);
	ullong FUN [LFTA_LEGAL,COST FREE]ULLONG(ullong);
	ullong FUN [LFTA_LEGAL,COST FREE]ULLONG(llong);
	ullong FUN [LFTA_LEGAL,COST FREE]ULLONG(float);

	llong FUN [LFTA_LEGAL,COST FREE]LLONG(uint);
	llong FUN [LFTA_LEGAL,COST FREE]LLONG(int);
	llong FUN [LFTA_LEGAL,COST FREE]LLONG(ullong);
	llong FUN [LFTA_LEGAL,COST FREE]LLONG(llong);
	llong FUN [LFTA_LEGAL,COST FREE]LLONG(float);

	llong FUN [LFTA_LEGAL,COST LOW] to_llong(string);

///////////////////////////////////////////////////////////
//          Numeric functions
///////////////////////////////////////////////////////////

	float FUN [LFTA_LEGAL, COST LOW] sqrt(float); 
	float FUN [LFTA_LEGAL, COST LOW] pow(float, float); 
	float FUN [LFTA_LEGAL, COST LOW] sin(float); 
	float FUN [LFTA_LEGAL, COST LOW] cos(float); 
	float FUN [LFTA_LEGAL, COST LOW] tan(float); 
	float FUN [LFTA_LEGAL, COST LOW] asin(float); 
	float FUN [LFTA_LEGAL, COST LOW] acos(float); 
	float FUN [LFTA_LEGAL, COST LOW] atan(float); 
	float FUN [LFTA_LEGAL, COST LOW] log(float); 
	float FUN [LFTA_LEGAL, COST LOW] log2(float); 
	float FUN [LFTA_LEGAL, COST LOW] log10(float); 
	float FUN [LFTA_LEGAL, COST LOW] ceil(float); 
	float FUN [LFTA_LEGAL, COST LOW] floor(float); 
	float FUN [LFTA_LEGAL, COST LOW] fmod(float); 
	float FUN [LFTA_LEGAL, COST LOW] trunc(float); 



///////////////////////////////////////////////////////////
//          Convert an IPv4 address 
///////////////////////////////////////////////////////////


    uint FUN [PARTIAL,COST HIGH] strtoi(string);
	IP FUN [PARTIAL,COST HIGH] strtoip(string); 

//	for constant strings - faster at runtime
	uint FUN [LFTA_LEGAL,COST LOW] strtoi_c(string HANDLE);
	IP FUN [LFTA_LEGAL,COST LOW] strtoip_c(string HANDLE); 


/////////////////////////////////////////////////////////////
//	Add up uints in a delimited ascii list.
//	return 135 on '34|45|56' and sep '|'

	llong FUN [LFTA_LEGAL,COST LOW] sum_uint_in_list(string, string CONST);


///////////////////////////////////////////////////////////
//          Compute running sum
///////////////////////////////////////////////////////////



    ullong UDAF [RUNNING, SUBAGGR moving_sum_lfta, SUPERAGGR super_moving_sum_udaf ] moving_sum_udaf fstring12 (uint, uint);

	uint EXTR moving_sum moving_sum_udaf moving_sum_extract (uint,uint);
	uint FUN  [COST LOW] moving_sum_extract(ullong);

	float EXTR moving_sum_exp moving_sum_udaf moving_sum_extract_exp (uint,uint, float);
	float FUN  [COST LOW]  moving_sum_extract_exp(ullong, float);

	ullong UDAF [RUNNING] super_moving_sum_udaf fstring12 (ullong);
	ullong UDAF moving_sum_lfta fstring8 (uint, uint);


///////////////////////////////////////////////////////////
//               Compute the average of 
//		all positive numbers 
///////////////////////////////////////////////////////////

	float UDAF POSAVG fstring16(float);


///////////////////////////////////////////////////////////
//               Simple average example 
///////////////////////////////////////////////////////////

	float EXTR extr_avg avg_udaf extr_avg_fcn (uint);
	float FUN extr_avg_fcn (string);
	string UDAF[SUBAGGR avg_udaf_lfta, SUPERAGGR avg_udaf_hfta] avg_udaf fstring12 (uint);
	string UDAF avg_udaf_hfta fstring12 (string);
	string UDAF avg_udaf_lfta fstring12 (uint);

///////////////////////////////////////////////////////////
//               SAMPLING 
///////////////////////////////////////////////////////////

        fstring100 STATE smart_sampling_state;
	int SFUN packet_count smart_sampling_state ();
	float SFUN gamma smart_sampling_state ();
	int SFUN do_clean_count smart_sampling_state ();
	int SFUN init_threshold smart_sampling_state ();
        int SFUN delay smart_sampling_state();
        int SFUN newly_closed smart_sampling_state();

///////////////////////////////////////////////////////////
//               Manku Heavy Hitter 
///////////////////////////////////////////////////////////

 
 	fstring20 STATE manku_hh_state;
	BOOL SFUN local_count manku_hh_state (UINT);
        int SFUN current_bucket manku_hh_state ();

///////////////////////////////////////////////////////////
//         Flips approximate quantile
///////////////////////////////////////////////////////////

// uint
        uint EXTR quantile_of quant_ui_udaf_hftaZ extr_quant_ui_hftaZ_fcn (uint, float);
        uint  FUN [COST LOW] extr_quant_ui_hftaZ_fcn(string, float);
        uint EXTR median_of quant_ui_udaf_hftaZ extr_med_ui_hftaZ_fcn (uint);
        uint  FUN [COST LOW] extr_med_ui_hftaZ_fcn(string);

        string UDAF [SUBAGGR quant_ui_udaf_lfta3, SUPERAGGR quant_ui_udaf_hfta3] quant_ui_udaf_hftaZ fstring32 (uint);
        string UDAF quant_ui_udaf_hfta3 fstring32 (string);
        string UDAF quant_ui_udaf_lfta3 fstring2088 (uint);
// int
        int EXTR quantile_of quant_i_udaf_hftaZ extr_quant_i_hftaZ_fcn (int, float);
        int  FUN [COST LOW] extr_quant_i_hftaZ_fcn(string, float);
        int EXTR median_of quant_i_udaf_hftaZ extr_med_i_hftaZ_fcn (int);
        int  FUN [COST LOW] extr_med_i_hftaZ_fcn(string);

        string UDAF [SUBAGGR quant_i_udaf_lfta3, SUPERAGGR quant_i_udaf_hfta3] quant_i_udaf_hftaZ fstring32 (int);
        string UDAF quant_i_udaf_hfta3 fstring32 (string);
        string UDAF quant_i_udaf_lfta3 fstring2088 (int);
// ullong
        ullong EXTR quantile_of quant_ul_udaf_hftaZ extr_quant_ul_hftaZ_fcn (ullong, float);
        ullong  FUN [COST LOW] extr_quant_ul_hftaZ_fcn(string, float);
        ullong EXTR median_of quant_ul_udaf_hftaZ extr_med_ul_hftaZ_fcn (ullong);
        ullong  FUN [COST LOW] extr_med_ul_hftaZ_fcn(string);

        string UDAF [SUBAGGR quant_ul_udaf_lfta3, SUPERAGGR quant_ul_udaf_hfta3] quant_ul_udaf_hftaZ fstring32 (ullong);
        string UDAF quant_ul_udaf_hfta3 fstring32 (string);
        string UDAF quant_ul_udaf_lfta3 fstring2904 (ullong);
// llong
        llong EXTR quantile_of quant_l_udaf_hftaZ extr_quant_l_hftaZ_fcn (llong, float);
        llong  FUN [COST LOW] extr_quant_l_hftaZ_fcn(string, float);
        llong EXTR median_of quant_l_udaf_hftaZ extr_med_l_hftaZ_fcn (llong);
        llong  FUN [COST LOW] extr_med_l_hftaZ_fcn(string);

        string UDAF [SUBAGGR quant_l_udaf_lfta3, SUPERAGGR quant_l_udaf_hfta3] quant_l_udaf_hftaZ fstring32 (llong);
        string UDAF quant_l_udaf_hfta3 fstring32 (string);
        string UDAF quant_l_udaf_lfta3 fstring2904 (llong);
// float
        float EXTR quantile_of quant_f_udaf_hftaZ extr_quant_f_hftaZ_fcn (float, float);
        float  FUN [COST LOW] extr_quant_f_hftaZ_fcn(string, float);
        float EXTR median_of quant_f_udaf_hftaZ extr_med_f_hftaZ_fcn (float);
        float  FUN [COST LOW] extr_med_f_hftaZ_fcn(string);

        string UDAF [SUBAGGR quant_f_udaf_lfta3, SUPERAGGR quant_f_udaf_hfta3] quant_f_udaf_hftaZ fstring32 (float);
        string UDAF quant_f_udaf_hfta3 fstring32 (string);
        string UDAF quant_f_udaf_lfta3 fstring2904 (float);

///////////////////////////////////////////////////////////
//               FIRST and LAST aggregation funciton
//	Should be replaced by builtins
///////////////////////////////////////////////////////////

// FIRST
	uint UDAF [RUNNING, SUBAGGR FIRST_lfta, SUPERAGGR FIRST_hfta] FIRST uint (uint);
	uint UDAF [RUNNING] FIRST_hfta uint (uint);
	uint UDAF [RUNNING] FIRST_lfta uint (uint);

	int UDAF [RUNNING, SUBAGGR FIRST_INT_lfta, SUPERAGGR FIRST_INT_hfta] FIRST int (int);
	int UDAF [RUNNING] FIRST_INT_hfta int (int);
	int UDAF [RUNNING] FIRST_INT_lfta int (int);

	ullong UDAF [RUNNING, SUBAGGR FIRST_ULL_lfta, SUPERAGGR FIRST_ULL_hfta] FIRST ullong (ullong);
	ullong UDAF [RUNNING] FIRST_ULL_hfta ullong (ullong);
	ullong UDAF [RUNNING] FIRST_ULL_lfta ullong (ullong);

	llong UDAF [RUNNING, SUBAGGR FIRST_LL_lfta, SUPERAGGR FIRST_LL_hfta] FIRST llong (llong);
	llong UDAF [RUNNING] FIRST_LL_hfta llong (llong);
	llong UDAF [RUNNING] FIRST_LL_lfta llong (llong);

	IP UDAF [RUNNING, SUBAGGR FIRST_lfta, SUPERAGGR FIRST_hfta] FIRST IP (IP);
	IP UDAF [RUNNING] FIRST_hfta IP (IP);
	IP UDAF [RUNNING] FIRST_lfta IP (IP);

	string UDAF [RUNNING, SUBAGGR FIRST_STR_lfta, SUPERAGGR FIRST_STR_hfta] FIRST string (string);
	string UDAF [RUNNING] FIRST_STR_hfta string (string);
	string UDAF [RUNNING] FIRST_STR_lfta string (string);


// LAST
	uint UDAF [RUNNING, SUBAGGR LAST_lfta, SUPERAGGR LAST_hfta] LAST uint (uint);
	uint UDAF [RUNNING] LAST_hfta uint (uint);
	uint UDAF [RUNNING] LAST_lfta uint (uint);

	int UDAF [RUNNING, SUBAGGR LAST_INT_lfta, SUPERAGGR LAST_INT_hfta] LAST int (int);
	int UDAF [RUNNING] LAST_INT_hfta int (int);
	int UDAF [RUNNING] LAST_INT_lfta int (int);

	ullong UDAF [RUNNING, SUBAGGR LAST_ULL_lfta, SUPERAGGR LAST_ULL_hfta] LAST ullong (ullong);
	ullong UDAF [RUNNING] LAST_ULL_hfta ullong (ullong);
	ullong UDAF [RUNNING] LAST_ULL_lfta ullong (ullong);

	llong UDAF [RUNNING, SUBAGGR LAST_LL_lfta, SUPERAGGR LAST_LL_hfta] LAST llong (llong);
	llong UDAF [RUNNING] LAST_LL_hfta llong (llong);
	llong UDAF [RUNNING] LAST_LL_lfta llong (llong);

	IP UDAF [RUNNING, SUBAGGR LAST_lfta, SUPERAGGR LAST_hfta] LAST IP (IP);
	IP UDAF [RUNNING] LAST_hfta IP (IP);
	IP UDAF [RUNNING] LAST_lfta IP (IP);

	string UDAF [RUNNING, SUBAGGR LAST_STR_lfta, SUPERAGGR LAST_STR_hfta] LAST string (string);
	string UDAF [RUNNING] LAST_STR_hfta string (string);
	string UDAF [RUNNING] LAST_STR_lfta string (string);


////////////////////////////////////////////////////////////
//	count_diff aggregation
//	count the # times the payload is different from the previous value
/////////////////////////////////////////////////////////////

	uint UDAF [SUBAGGR count_diff_lfta_ui, SUPERAGGR count_diff_hfta] count_diff fstring16 (uint);
	uint UDAF  count_diff_hfta fstring16 (string);
	string UDAF  count_diff_lfta_ui fstring20 (uint);

	uint UDAF [SUBAGGR count_diff_lfta_i, SUPERAGGR count_diff_hfta] count_diff fstring16 (int);
	string UDAF  count_diff_lfta_i fstring20 (int);

	uint UDAF [SUBAGGR count_diff_lfta_ul, SUPERAGGR count_diff_hfta] count_diff fstring16 (ullong);
	string UDAF  count_diff_lfta_ul fstring20 (ullong);

	uint UDAF [SUBAGGR count_diff_lfta_l, SUPERAGGR count_diff_hfta] count_diff fstring16 (llong);
	string UDAF  count_diff_lfta_l fstring20 (llong);

	uint UDAF [SUBAGGR count_diff_lfta_s, SUPERAGGR count_diff_hfta] count_diff fstring16 (string);
	string UDAF  count_diff_lfta_s fstring20 (string);


////////////////////////////////////////////////////////////////
//	string aggregation via catenation
//////////////////////////////////////////////////////

	string UDAF [HFTA_ONLY] CAT_aggr fstring8 (string, string);

///////////////////////////////////////////////////////////
//               integer array aggregation function
//	We are going to store 4 values in LFTA in fixed size buffer
//  	plus one byte for array length (17 bytes total)
//  	HFTA will combine partial aggregates
//		This seems to create a string with a comma-separated list of the uints
///////////////////////////////////////////////////////////

	string UDAF [RUNNING, SUBAGGR running_array_aggr_lfta, SUPERAGGR running_array_aggr_hfta] running_array_aggr string (uint);
	string UDAF [RUNNING] running_array_aggr_hfta string (string);
	string UDAF [RUNNING] running_array_aggr_lfta fstring17 (uint);
	
//////////////////////////////////////////////////////////
//	Mapping functions
//	Should eventually be replaced by watchlist join ?
//////////////////////////////////
	string FUN [HFTA_ONLY, COST EXPENSIVE] int_to_string_map(llong, string HANDLE);
	string FUN [HFTA_ONLY, COST EXPENSIVE] int_to_string_map(ullong, string HANDLE);
	string FUN [HFTA_ONLY, COST EXPENSIVE] int_to_string_map(int, string HANDLE);
	string FUN [HFTA_ONLY, COST EXPENSIVE] int_to_string_map(uint, string HANDLE);

//////////////////////////////////////////////////////////
//	time-averaged aggregate.
//	time_avg(sample, ts, window_size)
	float UDAF [HFTA_ONLY, RUNNING] time_avg fstring44 (uint, llong, llong) ;
	float UDAF [HFTA_ONLY, RUNNING] time_avg fstring44 (int, llong, llong) ;
	float UDAF [HFTA_ONLY, RUNNING] time_avg fstring44 (ullong, llong, llong) ;
	float UDAF [HFTA_ONLY, RUNNING] time_avg fstring44 (llong, llong, llong) ;
	float UDAF [HFTA_ONLY, RUNNING] time_avg fstring44 (float, llong, llong) ;

// ------------------------------------------------------------
//		running_sum_max : get the running sum of an int,
//		be able to report this sum and also its max value
//		during the time window

	llong EXTR running_sum run_sum_max extr_running_sum (uint);
	llong EXTR running_sum run_sum_max extr_running_sum (int);
	llong EXTR running_sum run_sum_max extr_running_sum (llong);
	llong EXTR running_sum run_sum_max extr_running_sum (ullong);
	llong FUN [COST LOW] extr_running_sum(string);
	llong EXTR running_sum_max run_sum_max extr_running_sum_max (uint);
	llong EXTR running_sum_max run_sum_max extr_running_sum_max (int);
	llong EXTR running_sum_max run_sum_max extr_running_sum_max (llong);
	llong EXTR running_sum_max run_sum_max extr_running_sum_max (ullong);
	llong FUN [COST LOW] extr_running_sum_max(string);
	string UDAF [HFTA_ONLY, RUNNING] run_sum_max fstring16 (uint);
	string UDAF [HFTA_ONLY, RUNNING] run_sum_max fstring16 (int);
	string UDAF [HFTA_ONLY, RUNNING] run_sum_max fstring16 (ullong);
	string UDAF [HFTA_ONLY, RUNNING] run_sum_max fstring16 (llong);

// ------------------------------------------------------------
//	to_hex_string : allow printing of binary strings

	string FUN [HFTA_ONLY, COST EXPENSIVE] to_hex_string(string);

// -------------------------------------------------------------------
//	approx_count_distinct : approximate the count distinct by
//	taking minhashes.  accurate to 7%, tested up to 100M distinct
//	items.
//
//	TODO : allow running aggregates to be used in regular aggregation?

	float EXTR approx_count_distinct approx_count_distinct_udaf extr_approx_count_distinct(string);
	string UDAF approx_count_distinct_udaf fstring1000 (string);
	float FUN extr_approx_count_distinct(string);

	float EXTR running_approx_count_distinct running_approx_count_distinct_udaf extr_approx_count_distinct(string);
	string UDAF [RUNNING] running_approx_count_distinct_udaf fstring1000 (string);
	float FUN extr_approx_count_distinct(string);
